/**
 * @file    debug_uart.c
 * @brief   Panel UART 115200 8N1 (ANSI) do debugowania „w miejscu”, TX nieblokujące (IRQ).
 * @date    2025-11-02
 *
 * CO:
 *   - Wysyłanie tekstu/ascii z użyciem HAL_UART_Transmit_IT i bufora pierścieniowego.
 *   - Dwukolumnowy panel RIGHT(I2C1)|LEFT(I2C3) jak w Twoim baseline.
 *
 * PO CO:
 *   - Brak blokowania pętli głównej (App_Tick), brak timeoutów i HAL_MAX_DELAY.
 *
 * KIEDY:
 *   - Wywołuj DebugUART_SensorsDual() co CFG_Scheduler()->uart_ms (jak było).
 */

#include "debug_uart.h"       // publiczne API modułu
#include <string.h>           // strlen, memset
#include <stdio.h>            // snprintf, vsnprintf
#include <stdarg.h>           // va_list

#include "stm32l4xx_hal.h"    // HAL
#include "tf_luna_i2c.h"      // TF_LunaData_t, TF_Luna_AmbientEstimateC
#include "tcs3472.h"          // TCS3472_Data_t

/* ========================== UCHWYT UART + STAN TX =========================== */
static UART_HandleTypeDef *s_uart = NULL;              // uchwyt ustawiany w DebugUART_Init()

/* Bufor pierścieniowy TX — całkowicie wewnętrzny dla kompatybilności API */
static uint8_t s_tx_rb[DEBUG_UART_RB_SIZE];            // pamięć kolejki TX
static volatile size_t s_head = 0;                     // indeks dopisania (head)
static volatile size_t s_tail = 0;                     // indeks czytania (tail)
static volatile uint8_t s_tx_busy = 0;                 // 1 = aktualnie trwa wysyłka (IT)
static size_t s_active_len = 0;                        // ilość bajtów aktualnej porcji

/* Krótkie makra sekcji krytycznej (wyłączamy IRQ na czas modyfikacji wskaźników) */
#ifndef ENTER_CRIT
#define ENTER_CRIT()  uint32_t _primask = __get_PRIMASK(); __disable_irq()
#define EXIT_CRIT()   do { if(!_primask) __enable_irq(); } while(0)
#endif

/* Pomocnicze: ile zajęte/ile wolne w kolejce (1 bajt "pustki" dla rozróżnienia) */
static inline size_t rb_used(void) { return (s_head - s_tail) % DEBUG_UART_RB_SIZE; }
static inline size_t rb_free(void) { return DEBUG_UART_RB_SIZE - 1u - rb_used(); }

/* Startuje wysyłkę następnej porcji (jeśli nie trwa). Porcja = ciągły fragment do końca bufora. */
static void try_kick_tx(void)
{
    if (!s_uart) return;                   // brak UART → nic nie robimy
    if (s_tx_busy) return;                 // już trwa poprzednia wysyłka

    size_t head = s_head;                  // lokalne kopie (atomowe odczyty)
    size_t tail = s_tail;

    if (head == tail) return;              // kolejka pusta

    size_t chunk = (head > tail) ? (head - tail) : (DEBUG_UART_RB_SIZE - tail); // liniowo do końca
    s_active_len = chunk;                  // zapamiętujemy, ile bajtów idzie w tej porcji
    s_tx_busy = 1;                         // oznacz, że wysyłamy

    /* Rozpocznij transmisję przerwaniami (asynchronicznie). */
    HAL_StatusTypeDef st = HAL_UART_Transmit_IT(s_uart, &s_tx_rb[tail], (uint16_t)chunk);
    if (st != HAL_OK) {
        /* Jeśli HAL nie wystartował TX (np. błąd) – odznacz busy, spróbujemy później. */
        s_tx_busy = 0;
        s_active_len = 0;
    }
}

/* Wrzuca bajty do kolejki TX (bez blokowania). Zwraca ile naprawdę wpadło. */
static size_t DebugUART_Write(const void *data, size_t len)
{
    if (!s_uart || !data || len == 0) return 0;

    const uint8_t *p = (const uint8_t*)data;
    size_t written = 0;

    ENTER_CRIT();                           // zabezpiecz wskaźniki kolejki
    while (written < len && rb_free() > 0)  // dopóki są dane i jest miejsce
    {
        s_tx_rb[s_head] = p[written];       // wpisz bajt
        s_head = (s_head + 1u) % DEBUG_UART_RB_SIZE; // przesuń head (zawijanie)
        written++;
    }
    EXIT_CRIT();

    /* Po dopisaniu spróbuj wystartować TX, jeśli nic jeszcze nie leci. */
    try_kick_tx();
    return written;                          // uwaga: może być < len (brak miejsca)
}

/* ============================== API ================================= */

void DebugUART_Init(UART_HandleTypeDef *huart)
{
    s_uart = huart;                          // zapamiętaj uchwyt
    ENTER_CRIT();
    s_head = s_tail = 0;                     // wyczyść wskaźniki
    s_tx_busy = 0;
    s_active_len = 0;
    EXIT_CRIT();
}

/* Wysyła msg + CRLF, nieblokująco. Jeśli kolejka pełna, nadmiar zostanie pominięty. */
void DebugUART_Print(const char *s)
{
    if (!s) return;                           // brak stringa → nic nie rób
    (void)DebugUART_Write(s, strlen(s));      // wrzuć treść
    (void)DebugUART_Write("\r\n", 2u);        // i CRLF w spójnym stylu
}

/* Formatowanie do lokalnego bufora + enqueue (nieblokująco). */
void DebugUART_Printf(const char *fmt, ...)
{
    if (!fmt) return;

    char buf[160];                            // lokalny bufor formatowania
    va_list ap;
    va_start(ap, fmt);
    (void)vsnprintf(buf, sizeof(buf), fmt, ap);
    va_end(ap);

    (void)DebugUART_Write(buf, strlen(buf));  // treść
    (void)DebugUART_Write("\r\n", 2u);        // CRLF
}

/* ============================ ANSI HELPER ============================ */
/* Czyści cały ekran i ustawia kursor na (1,1) — również nieblokująco. */
static void term_clear(void)
{
    static const char cmd[] = "\x1b[2J\x1b[H";          // ESC[2J (clear) + ESC[H (home)
    (void)DebugUART_Write(cmd, sizeof(cmd) - 1u);       // do kolejki, bez czekania
}

/* ========================== PANEL DIAGNOSTYCZNY ====================== */
void DebugUART_SensorsDual(const TF_LunaData_t *RightLuna,
                           const TF_LunaData_t *LeftLuna,
                           const TCS3472_Data_t *RightColor,
                           const TCS3472_Data_t *LeftColor)
{
    if (!s_uart || !RightLuna || !LeftLuna || !RightColor || !LeftColor) return;

    term_clear();                                        // nowa „rama” panelu

    char line[160];
    const char *stR = RightLuna->frameReady ? "OK " : "NO FRAME";
    const char *stL = LeftLuna->frameReady  ? "OK " : "NO FRAME";

    DebugUART_Print("                  DzikiBoT (Parametry Sensorów)");
    DebugUART_Print("-------------------------------+-------------------------------------");
    DebugUART_Print("            RIGHT (I2C1)       |               LEFT (I2C3)");
    DebugUART_Print("-------------------------------+-------------------------------------");

    /* DIST – mediana (distance_filt) */
    (void)snprintf(line, sizeof(line),
                   " Dist:  %4ucm  (%-8s)     | Dist:  %4ucm  (%-8s)",
                   (unsigned)RightLuna->distance_filt, stR,
                   (unsigned)LeftLuna->distance_filt,  stL);
    DebugUART_Print(line);

    /* STR – średnia krocząca (strength_filt) */
    (void)snprintf(line, sizeof(line),
                   " Str : %5u                   | Str : %5u",
                   (unsigned)RightLuna->strength_filt,
                   (unsigned)LeftLuna->strength_filt);
    DebugUART_Print(line);

    /* TEMP (module °C) – już w 0.1°C w driverze */
    (void)snprintf(line, sizeof(line),
                   " Temp: %5.1f C                 | Temp: %5.1f C",
                   (double)RightLuna->temperature,
                   (double)LeftLuna->temperature);
    DebugUART_Print(line);

    /* AMBIENT (est.) – offset wg CFG_Luna()->temp_offset_c */
    {
        float ambR = TF_Luna_AmbientEstimateC(RightLuna);
        float ambL = TF_Luna_AmbientEstimateC(LeftLuna);

        (void)snprintf(line, sizeof(line),
                       " Amb.: %5.1f C (est)           | Amb.: %5.1f C (est)",
                       (double)ambR, (double)ambL);
        DebugUART_Print(line);
    }

    DebugUART_Print("-------------------------------+-------------------------------------");

    /* RGB/C (skalowane /64 – spójnie z UI) */
    {
        unsigned rR = RightColor->red   / 64u;
        unsigned gR = RightColor->green / 64u;
        unsigned bR = RightColor->blue  / 64u;
        unsigned cR = RightColor->clear / 64u;

        unsigned rL = LeftColor->red    / 64u;
        unsigned gL = LeftColor->green  / 64u;
        unsigned bL = LeftColor->blue   / 64u;
        unsigned cL = LeftColor->clear  / 64u;

        (void)snprintf(line, sizeof(line),
                       " R:%4u G:%4u B:%4u C:%5u  | R:%4u G:%4u B:%4u C:%5u",
                       rR, gR, bR, cR, rL, gL, bL, cL);
        DebugUART_Print(line);
    }
}

/* ========================== HAL CALLBACK (IRQ) ======================= */
/* HAL wywołuje tę funkcję po wysłaniu porcji; filtrujemy po naszym UART. */
void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
{
    if (huart != s_uart) return;                         // nie nasz UART → ignoruj

    ENTER_CRIT();
    s_tail = (s_tail + s_active_len) % DEBUG_UART_RB_SIZE; // ogon przesuwa się o wysłaną porcję
    s_active_len = 0;
    s_tx_busy = 0;                                       // zwolnij „busy”
    EXIT_CRIT();

    try_kick_tx();                                       // jeśli coś jeszcze czeka, start kolejnej porcji
}
